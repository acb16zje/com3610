\documentclass[12pt, a4paper]{report}
\edef\restoreparindent{\parindent=\the\parindent\relax}
\usepackage[UKenglish]{babel}
\usepackage[bibstyle=ieee, dashed=false, sorting=nty]{biblatex}
\usepackage[labelfont=bf]{caption}
\usepackage{colortbl}
\usepackage{csquotes}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage[bottom]{footmisc}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{pgfgantt}

\linespread{1.2}
\restoreparindent

\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{\leftmark}
\fancyfoot[C]{\thepage}

\addbibresource{references.bib}

\begin{document}
\begin{titlepage}
	\centering
	\includegraphics[width=10cm]{tuos_logo}\par\vspace{1cm}
	\vspace{1cm}

	{\huge\bfseries Finding Security Issues in (Open Source) Software Repositories\par}
	\vspace{1cm}

	{\Large Zer Jun Eng\par}
	\vspace{1cm}

	supervised by\par Dr.~Achim \textsc{Brucker}
	\vfill

	{This report is submitted in partial fulfilment of the requirement for the degree of MEng Software
		Enginnering by Zer Jun Eng}
	\vfill

	{\large COM3610}
	\vfill

	{\large \today}
\end{titlepage}

\pagenumbering{roman}

\chapter*{Declaration}
\addcontentsline{toc}{chapter}{Declaration}
All sentences or passages quoted in this report from other people's work have been specifically
acknowledged by clear cross-referencing to author, work and page(s). Any illustrations that are not
the work of the author of this report have been used with the explicit permission of the originator
and are specifically acknowledged. I understand that failure to do this amounts to plagiarism and
will be considered grounds for failure in this project and the degree examination as a whole.
\vspace{2cm}

\noindent \begin{tabular}{llp{4.5cm}}
	Name & : & Zer Jun Eng \\ \cline{3-3}
	\\ [-0.5em]
	Date & : & \today      \\ \cline{3-3}
\end{tabular}

\newpage

% \chapter*{Abstract}
% \addcontentsline{toc}{chapter}{Abstract}

\chapter*{Acknowledgements}
\addcontentsline{toc}{chapter}{Acknowledgements}
I would firstly like to thank my parents for their unconditional love and the full financial supoprt
throughout my university life. It would not be possible for me to finish this project and my course
without them.

I would also like to thank my supervisor, Dr. Achim Brucker, who are continuously providing
constructive advice for my project. I am honoured to work with you, and I look forward to working
with you in the future.

\newpage

\tableofcontents

% \listoffigures \addcontentsline{toc}{chapter}{List of Figures}

\listoftables \addcontentsline{toc}{chapter}{List of Tables}

\newpage

\pagenumbering{arabic}

\chapter{Introduction}
\section{Background}
Free/Libre and Open Source Software (\textbf{FLOSS}) is a type of software which its license allows
the users to inspect, use, modify and redistribute the software's source code \cite{crowston_2012}.
Since the introduction of Git, and later the Git repositories hosting site such as GitHub, many
users have started to make their softwares open source by storing them as public repositories on
GitHub. As a result, the participation of global communities into FLOSS projects has started to grow
and different contributions were made to improve the softwares quality, which included fixing the
software vulnerabilities \cite{dabbish_2012}.

Building a secure software is expensive, difficult, and time-consuming. In FLOSS projects, it is
necessary to know when and how a security vulnerability is fixed. Therefore, having a list of
changelogs or informative git commit messages that record the fixed security vulnerabilities is
helpful. However, Arora and Telang \cite{arora_2005} stated that some open source developers believe
that public disclosure of security vulnerabilities patch is dangerous, thus vulnerability fixing
commits are not commonly identified in some open source software repositories to prevent malicious
exploits. Hence, a repository mining tool that investigate vulnerability patterns and identify
vulnerable software components can be developed to reduce the time and cost required to mitigate the
vulnerabilities.

\section{Objectives}
\label{sec:objectives}
\begin{itemize}
	\item Identify the security patterns of the most popular security issues in OWASP Top Ten Project.
	The patterns should be expressed using regular expressions.
	\item Develop a repository mining tool to search through the commit history of a repository and
	find a list of commit messages that match the patterns. The list should be produced in a suitable
	file format such as JSON, XML, or CSV.
	\item Extend the mining tool which checks the code difference in the commits found to obtain the
	actual commits fixing the security vulnerabilities. This extension should separate from the mining
	process to make the mining results easier to verify and debug.
\end{itemize}

\section{Challenges}
\begin{itemize}
	\item \textbf{Data}: There are a large number of open source repositories available on GitHub.
	However, it is challenging to find a set of sample repositories that can produce accurate and
	consistent results.
	\item \textbf{Misclassification}: Commit messages for a same vulnerability patch are not always
	the same, thus misclassification of commit messages is inevitable. Using regular expressions to
	match the patterns in the mining process does not guarantee correctness of the result.
	\item \textbf{Evaluation}: After mining a list of commits that contain the identified patterns in
	its message, the evaluation process might not correctly locate the lines of code that addressed
	the security vulnerability. It might be required to perform manual evaluation to correctly
	identify some of the results.
	\item \textbf{Time}: Large repository such as Linux which has more than 780,000 commits in total
	\cite{linux_repo} could be extremely time-consuming for the repository mining tool to complete the
	search and evaluation process.
\end{itemize}

\section{Report Structure}
\textbf{Chapter 2} reviews a range of academic articles, theories and previous studies that
is related to this project, as well as investigating the techniques and tools to be used.

\noindent\textbf{Chapter 3} is a list of detailed requirements and a thorough analysis for design,
implementation and testing stage. Some core decisions are reviewed in the analysis part to ensure
the feasibility of the project.

\noindent\textbf{Chapter 4} is a comparison between different design concepts, where the advantages
and disadvantages of difference approach are stated. The chosen design is justified with suitable
diagrams provided including wireframes and UML.

\noindent\textbf{Chapter 5} describes the implementation process by highlighting novel aspects to
the algorithms used. Testing are performed by following a suitable model to evaluate the
implementation.

\noindent\textbf{Chapter 6} presents all the results along with critical discussions about the main
findings,	and outlines the possible improvements that could be made in the future work.

\noindent\textbf{Chapter 7} summarises the main points of previous chapters and emphasise the
results found.

\section{Relationship to Degree Programme}
This project focuses on the reserach of real-world software security problems, and offers a valuable
insights into the computer security. By studying the patterns of security vulnerabilities patch,
practical knowledge for building and ensuring a secure system could be gained. Moreover, the
difficulty of improving software security could be experienced during the evaluation process in this
project. This relates to the Software Engineering degree as it requires a good understanding in
version control system and it aims to improve softwares quality by reducing the time and effort
needed to find security vulnerabilities in the source code.

\chapter{Literature Review}
This chapter will start with the background contents of the project, and then focus on discussing
the security aspect of open source softwares. Lastly, previous and existing relevant work are
reviewed and a critical analysis is provided for the comparison of these resources and this project.

\section{Open Source Security}
There are currently two approaches to the license distribution of software: open source and closed
source. The users of closed source software are limited to accept the level of security
provided by their chosen vendor. In contrast, open source softwares provide more flexibility and
freedom over the security option to their users \cite{payne_2002}, where the users can decide to
wait for a patch from the vendor or collaborate with the community to develop their own.

Hoepman and Jacobs \cite{hoepman_2007} suggested that open source softwares will have better
security and reliability than closed source softwares through the power of open data and
crowdsourcing. Conversely, Schryen \cite{schryen_2011} has shown that open source and closed source
softwares do not have significant security dfference in his experiment and concluded that the policy
of the developers is the main factor that determines the security. Wheeler \cite{wheeler_2015}
agrees with Schryen's conclusion, but he argued that Schryen's experiment had a small sample size,
so the results may not be accurate.

While both statements might be true, Cowan \cite{cowan_2003} indicated that the security of a
software is determined by many factors, and the source availability model is not the primary driver.
Witten, Landwehr, and Caloyannides \cite{witten_2001} stated that code review is the most effective
method to improve system security and deduced that closed source systems could reach the same
security level as open source systems if there were sufficient review processes being carried out.
In recent years, the growing popularity of open source softwares has attracted a large number of
people to join the community. Some open source softwares are now believed to have better quality as
compared to their respective closed source softwares. However, this argument has yet to be proven in
a formal way.

\section{Common Vulnerabilities and Exposures}
The Common Vulnerabilities and Exposures (\textbf{CVE}) is a project launched by Mitre Corporation
and sponsored by the National Cyber Security Division of the United States Department of Homeland
Security \cite{cve}. The CVE system provides the computer security community with a complete list of
publicly known security vulnerabilities, and each vulnerability is identified by a unique CVE ID
number. It is now the standardised solution and industry-recognised standard for identifying
vulnerabilities and exposures.

\section{Common Weakness Enumeration}
The Common Weakness Enumeration (\textbf{CWE}) is another project of Mitre Corporation \cite{cwe}
that organises the software weaknesses into a list of different categories, known as the CWE list.
Software weaknesses are defined as the errors that can lead to software vulnerabilities, which
includes buffer overflows, authentication errors, code injection, etc. \cite{cwe_faq}. The CWE is
now a formal standard for representing software weaknesses. Each entry in the CWE are identified by
a unique ID number, and contained detailed information about the specific weakness.

\section{Security Issues in Open Source Softwares}
The Open Web Application Security Project (\textbf{OWASP}) is a worldwide non-profit organization
committed to improve and raise the awareness of software security \cite{owasp_home}. The project
members of OWASP have worked together to produce a list of the most critical web application
security risks based on the community feedback and comprehensive data contributed by different
organizations. The list consists of ten categories of security attacks which are considered to be
the most dangerous and popular in the recent years. The vulnerabilities listed by OWASP in 2017
\cite{owasp_top10} will be analysed and the security risks listed in older versions of the top ten
project will covered too.

\subsection{Injection}
An injection attack is the exploitation of a software vulnerability where the attacker injects
malicious code into the software applications and perform harmful executions. The most common types
of injection attacks are Structured Query Language (\textbf{SQL}) injection, cross-site scripting,
and shell injection \cite{pietraszek_2006}. Among these attacks, SQL injection attacks required the
most effort to fix \cite{othmane_2015}. This is because a successful SQL injection attack could
delete an entire database that could cause a massive data loss in extreme situation. SQL injection
attacks are very widespread and easy to discover especially when attackers have access to the source
code, or they could use a code scanner tool such as sqlmap \cite{sqlmap} to find all possible ways
of the injection attacks.

Vast majority of web applications make use of JavaScript to add automation and interactivity to
their web pages to enhances the user experience. However, the growing usage of JavaScript has also
increased the frequency and popularity of cross-site scripting (\textbf{XSS}) attacks. There three
types of XSS attacks are: \textit{reflected XSS}, \textit{stored XSS}, and \textit{DOM XSS}
\cite{kieyzun_2009}. While the attack approach of different XSS methods may vary, their end goal is
to steal or access the sensitive information of the victims \cite{vogt_2007}. XSS vulnerabilities
could be easily detected and exploited at the same time, for example, the open source tool XSStrike
\cite{xsstrike} can scan a web page for possible {XSS vulnerabilities. A promising approach to
tackle this problem would be adding an extra security mechanism for handling the user inputs on the
web pages.

\subsection{Broken Authentication}
Broken authentication happens when the attackers are allowed to perform malicious actions such as
brute force dictionary attack on the authentication system. It might also be one of the outcome of a
successful injection attack. According to Huluka and Popov \cite{huluka_2012}, this vulnerability
are very prevalent and has various causes, in which the lack of attention to security details is the
most critial because developers often overlook certain scenarios which are likely to be exploited by
attackers.

\subsection{Using Componenets with Known Vulnerabilities}
Components such as plugins, libraries, and modules can often be found in different parts of a
software. Third-party components are increasingly being integrated into softwares to reduce the
amount of time and effort required for development \cite{balzarotti_2006}, but they also increase
the risk of vulnerabilities being introduced into the softwares. These components are mostly
maintened by different developers or organisations hence it is unable to guarantee that all the
components used will be provided with the latest security patch.

Cadariu et al. \cite{cadariu_2015} used OWASP Dependency Check tool \cite{owasp_dependency} to find
all known vulnerabilities in proprietary softwares written in Java. However, their results contained
a considerable amount of both false positives and false negatives, which directly affected the
precision of their technique. Therefore, it is also expected that the final results produced in this
project might encounter the same problem.

\section{Vulnerabilities Classification Techniques}
Many classification techniques of computer attacks have been introduced before open source became
popular, and these early works have significant influence on the later work of finding and
classifying security issues in open source software repositories. An early work of Lindqvist and
Jonsson \cite{lindqvist_1999} implied that the \textit{location} of a computer flaw is a determining
factor in the classification process, in which their results are obtained through real penetration
attacks. Hansman and Hunt \cite{hansman_2005} adapted the ideas of Lindqvist and Jonsson and
suggested the concept of dimensions, where they categorised the attacks into several layers.

\section{Mining Software Repositories}
Mining Software Repositories (\textbf{MSR}) is a process of collecting and analysing big data from
repositories, which includes version control repositories, mailing list repositories, and bug
tracking repositories. The purpose of mining software repositories is to extract practical
information from rich metadata and discover hidden trends about a specific evolutionary
characteristic \cite{kagdi_2007}. The information collected could be used in various development
process. For example, some developers could gain insight by mining repositories, which may help them
to enhance their software quality based on previous implementation evidence of other developers
\cite{hassan_2008}.

Matsushita, Sasaki, and Inoue \cite{matsushita_2005} developed a system known as CoxR that is able
to analyse open source repositories to search for code fragments, files and commit logs through the
keywords provided. The CoxR system has an integrated analysis module, and the module consists of two
functions: lexical analysis function and token comparing function. Although the main objective of
CoxR system is not about finding security related commits in open source repositories, the
methodology of CoxR system for searching the commit history is suitable to be used as an
implementation reference.

Williams and Hollingsworth \cite{williams_2005} developed a source code analysis tool that searches
for bug fixes and combines with information mined from repositories to improve the results. It is
stated that the most efficient way to utilise the historical information is to ignore the commit
messages and focus on mining the code changes. In order to locate the actual code changes for the
bug fix, a function return value checker was implemented to compares the number of warnings produced
by a same function across different versions. Williams and Hollingsworth assumed that a bug is fixed
if the warnings produced by the same function have decreased between two versions, and the final
result produced is a list of functions that are related to a potential bug fix in the commit
history.

This project extends prior work on Reis and Abreu's \cite{secbench} Secbench Mining Tool. The tool
aims to find vulnerabilities patch in GitHub repositories by using specific regular expressions for
each vulnerability pattern. Then it creates a test case for every vulnerability found and these test
cases are evaluated manually. Reis and Abreu \cite{reis_2017} discussed the procedure of the
evaluation and explained that human errors could occur due to source code complexity and similarity
of vulnerability pattern. The approach of Secbench Mining Tool is similar to the concept of this
project. However, it is not practical to perform manual evaluation on every result. In this project,
the tool developed should be able to automate the evaulation process to some extent, while
preserving the accuracy of the results.

\chapter{Requirements and Analysis}
The purpose of this chapter is to express the aims in more details, and discuss the problems to be
solved. This chapter will outline the requirements of the project and list the criteria to be met.
The analysis part will cover every aspect of the design, implementation and testing stage to ensure
that the project is feasible.

\section{Project Objectives}
Initially, the objectives set in \hyperref[sec:objectives]{\textbf{Section 1.2}} are an ideal
concept of this project. Having completed the background research and literature review, it is now
possible to provide a detailed description and more clearly defined objectives that improve the
feasibility of this project.

\begin{enumerate}
	\item \textbf{Vulnerability patterns}: Identifying the each of the vulnerability pattern
	independently and individually is a time-comsuming process. There is also no guarantee that the
	patterns will produce accurate results during the testing stage. Therefore, it is decided to reuse
	and improve the patterns provided in previous related work.
	\item \textbf{Mining the commits}: This task involves creating a repository mining tool that makes
	extensive use of the pre-defined regular expressions to search for the relative commits. It will
	be necessary to consider how closely a commit needs to match with the patterns for it to be
	included in the result. The file format of the result will be discussed in the later section.
	\item \textbf{Evaluating the mined commits}: The tool can be extended to include a separate
	function that evaluates the commits mined to find the actual code commit addressing the security
	vulnerabilities. However, all previous related work performed did not use automated techinques for
	the evaluation. This project will consider to automate the evaluation process to some extent while
	maintaining the accuracy of the results at the standard level.
\end{enumerate}

\section{Software Specification}
\begin{table}[H]
	\begin{center}
		\begin{tabular}{|p{9.5cm}|c|}
			\hline
			\rowcolor[HTML]{D8D8D8}
			\multicolumn{1}{|c|}{Criteria} & Importance \\ \hline
			\textbf{Compatibility}: The mining tool should be able to run on all machines that meet the
			system requirements. & Essential \\ \hline
			\textbf{Completeness}: The mining tool should be able to find all commits that match the
			regular expressions. & Essential \\ \hline
			\textbf{Repeatable}: The results should be repeatable and reproducible. & Essential \\ \hline
			\textbf{Robustness}: The mining tool should be able to handle all possible errors without
			terminating the mining process. & Essential \\ \hline
			\textbf{Automated Evaluation}: The process of classifying and evaluating the commits into
			different vulnerabilities patch should be automated to a certain extent. & Desirable \\ \hline
			\end{tabular}
		\captionof{table}{Criteria to be met in this project} \label{table:criteria}
	\end{center}
\end{table}

\section{Considerations}
The aim of this section is to contemplate the options available for the development of this project
and decide some of the fundamental decisions.

\subsection{Programming Language}
Python 3 \cite{python} is chosen to be the main programming language for the repository mining tool.
While other programming languages may be more suitable for tackling specific problems of this
project, Python 3 provides sufficient coverage over every aspect with its comprehensive
functionality. The greatest advantage of Python 3 is that it has a wide range of libraries that
facilitate the development environment, which fully justified that a complete working solution can
be produced using Python 3.

\subsection{Libraries and Tools}
\begin{itemize}
	\item PyGithub is a Python library build to access the GitHub API \cite{pygithub}.
	\item GitPython is a Python library build to interact with Git repositories using a combination of
	python and git command implementation \cite{gitpython}.
\end{itemize}

% \subsection{Testing}

% According to \hyperref[table:celltable]{\textbf{Table 3.1}}, \ref{table:celltable}

% \section{Problems}
% As mentioned in \hyperref[sec:objectives]{\textbf{Section 1.2}}, the repository mining tool must be
% able to detect commits that contain distinct patterns such as \textit{fix}, \textit{patch},
% \textit{vulnerability} etc. After extracting a possible list of commits, it should perform an
% evaluation process to identify the actual commits that fixed security vulnerability.	This could be
% hard because not all open source software repositories are using the same programming language.
% Hence, it might be difficult to determine the actual lines of code that addressed the
% vulnerabilities.

% One of the major challenges in this project is the classification or evaluation of the
% vulnerabilities.

% \section{Proposed Method}
% Build a command-line interface program that is able to run two separate process: the mining process
% and the evaluation process. The \textbf{mining} process takes a Git repository as input, searches
% through the commit log, and return the list of commits that might potentially contain a patch as a
% log file (JSON, HTML, etc.). The \textbf{evaluation} process takes a log file as input, and check
% the code difference of every commit in the log file to identify the real patches.

% \chapter{Design}

% \chapter{Implementation and Testing}

% \chapter{Results and Discussion}

% \chapter{Conclusion}

\printbibliography[heading=bibintoc]

\end{document}